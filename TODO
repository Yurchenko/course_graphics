важно
Записка 
 аналоги d3.js


Использовать в курсаче 
Visualization of large hierarchical data by circle packing
http://www.infovis-wiki.net/index.php?title=Circle_Packing


итак, основная проблема на сегодня - задать атрибут children для круга
туда можно пихать типа как только строки, что косяк
как выкручиваться будем, господа


СУПЕР ИДЕЯ - 
БРАТЬ .DOT ФАЙЛЫ ГРАФВИЗОВСКИЕ, ПРОВЕРЯЕМ НА ПЛАНАРНОСТЬ
ПЕРЕХУЯРИВАЕМ В JSON-ЧИК И ПО НИМ СТРОИМ КРАСОТУ 
ТИПА КАК ПЛАГИН ДЛЯ ГРАФВИЗА, МММ, классненько
ИЕРАРХИЕЧСКИЕ ГРАФЫ ОХУИТЕЛЬНО ПРЕДСТАВЛЯЮТСЯ
вообще про охуительность представления графов в таком виде

итак, новый способ получения JSONчиков!!!
.dot файл -> dot_to_JSON_converter -> JSON

  глобальные переменные
  canvas на котором мы рисуем
  current_graph на котором мы рисуем, которого мы ставим в родители, и детей которого мы рисуем

у канваса у нас есть HTMLCollection, собственно поэтому мы и "создаём" атрибут name у кругов на канвасе, потому что 
у HTMLCOllection есть метод namedItem, который ищет в коллекции именно по этому атрибуту объекта

для того чтобы вращать графы, каждый круг должен знать, какие круги лежат внутри него и в каком он сам лежит кругу
то есть нам нужно дереро, чтобы всё это удобно хранить. 
Следующий вопрос, нужно JSON делать как дерево или по JSONу делать дерево. Или просто наши SVG элементы должны составлять дерево. Ведь каждому элементу можно задать поля чайлд и пэрэнт. Скорее всего последний вариант! Ура! 

проверочку check_json нормально завернуть, обработка ошибок, вся хуйня
сейчас бестолковая

Как расположить эти ебучие круги?!?!?

где набрать примеров!?!??

проверка подграфа на то, что все имена уникальны
1) на уникальность имён вершин
на заметку = значения радиусов нам к хуям не упёрлись, поэтому при проверке можно
вообще тут два варианта 
а) можно "нормировать" это, то есть, чтобы хотя бы число были поменьше 
б) можно привести всё к интам, мб так лучше будет?)
итог: можно реализовать оба метода и протестировать какой из них лучше работает, если вообще будет виден 
прирост производительности
итог2: для этого нужно написать отдельную хуйню с тестами
нужен тест в глубину (супер дохуя вложений)
тест в ширину

Жадный алгоритм построения триангуляции(очень долго N^2 * log N)

Шаг 1. Генерируется список всех возможных отрезков, соединяю-
щих пары исходных точек, и он сортируется по длинам отрезков.
Шаг 2. Начиная с самого короткого, последовательно выполняется
вставка отрезков в триангуляцию. Если отрезок не пересекается с другими
ранее вставленными отрезками, то он вставляется, иначе он отбрасывается.
Конец алгоритма.
Заметим, что если все возможные отрезки имеют разную длину, то
результат работы этого алгоритма однозначен, иначе он зависит от порядка
вставки отрезков одинаковой длины. 


